{
  "version": 3,
  "sources": ["../../../app/routes/_index.tsx", "../../../node_modules/idb/build/index.js", "../../../app/utils/indexedDb.ts"],
  "sourcesContent": ["// REMIX HMR BEGIN\nif (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {\n  console.warn('remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.');\n} else {\n  var prevRefreshReg = window.$RefreshReg$;\n  var prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    window.$RefreshRuntime$.register(type, \"\\\"app/routes/_index.tsx\\\"\" + id);\n  }\n  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\n  import.meta.hot = __hmr__.createHotContext(\n  //@ts-expect-error\n  \"app/routes/_index.tsx\");\n  import.meta.hot.lastModified = \"1749039938698.0688\";\n}\n// REMIX HMR END\n\nimport axios from \"axios\";\nimport { useEffect, useState } from \"react\";\nimport { lazy, Suspense } from 'react';\nconst ProductCard = lazy(_c = () => import(\"~/component/ProductCard\"));\n_c2 = ProductCard;\nconst Pagination = lazy(_c3 = () => import('~/component/Pagination'));\n_c4 = Pagination;\nimport Header from \"~/component/Header\";\nimport { getFromIndexedDB, saveToIndexedDB } from \"~/utils/indexedDb\";\nexport const meta = () => [{\n  title: \"E commerce app\"\n}, {\n  name: \"description\",\n  content: \"Welcome to my e commerce app\"\n}];\nexport default function Index() {\n  _s();\n  const [loaderData, setLoaderData] = useState({\n    productData: {},\n    categories: {}\n  });\n  const [products, setProducts] = useState([]);\n  const [searchProducts, setSearchProducts] = useState([]);\n  const [searchKey, setSearchKey] = useState(\"\");\n  const [currentPage, setCurrentPage] = useState(1);\n  const productPerPage = 8;\n\n  // loader data from another file \n  useEffect(() => {\n    const fetchProducts = async () => {\n      const res = await axios.get(\"/fetchdata\");\n      setLoaderData(res.data);\n    };\n    fetchProducts();\n  }, []);\n\n  // Load data from IndexedDB (or use loader fallback)\n  useEffect(() => {\n    const loadProducts = async () => {\n      const dbData = await getFromIndexedDB();\n      if (dbData && Array.isArray(dbData) && dbData.length > 0) {\n        setProducts(dbData);\n      } else {\n        setProducts(loaderData?.productData);\n        await saveToIndexedDB(loaderData?.productData); // Save for later\n      }\n    };\n    loadProducts();\n  }, [loaderData?.productData]);\n\n  // Filter products by search key\n  useEffect(() => {\n    if (searchKey.trim() !== \"\") {\n      const filtered = products.filter(item => item.title.toLowerCase().includes(searchKey.toLowerCase()));\n      setSearchProducts(filtered);\n      setCurrentPage(1);\n    } else {\n      setSearchProducts([]);\n    }\n  }, [searchKey, products]);\n\n  // Save categories to local storage\n  useEffect(() => {\n    if (loaderData?.categories && Array.isArray(loaderData?.categories)) {\n      localStorage.setItem(\"categories\", JSON.stringify(loaderData?.categories));\n    }\n  }, [loaderData?.categories]);\n  const finalProducts = searchKey ? searchProducts : products;\n\n  // Page change\n  const handlePageClick = page => {\n    if (navigator.onLine) {\n      setCurrentPage(page);\n    } else {\n      alert(\"Check Your Internet Connection\");\n    }\n  };\n  return <div>\n          <Header currentPage={currentPage} searchKey={searchKey} setSearchKey={setSearchKey} />\n          {finalProducts.length > 0 ? <div>\n              <div className=\"min-h-screen\">\n                <div className=\"flex mt-10 mb-4 gap-4 sm:flex-row justify-center flex-wrap\">\n                  <Suspense fallback={<div>Loading products...</div>}>\n                    {finalProducts.slice((currentPage - 1) * productPerPage, currentPage * productPerPage).map(item => <ProductCard key={item.id} item={item} />)}\n                  </Suspense>\n                </div>\n              </div>\n              <Pagination limit={productPerPage} offset={currentPage} totalItems={finalProducts.length} onPageChange={handlePageClick} primaryColor=\"bg-primary_purple\" textColor=\"text-white\" totalToShow={5} />\n            </div> : <div className=\"my-10\">\n              <p className=\"text-xl text-center text-red-500\">No product found</p>\n            </div>}\n        </div>;\n}\n_s(Index, \"Qy3qIM7g6Fk6vxt7W6BZvkwD+bM=\");\n_c5 = Index;\nvar _c, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"ProductCard$lazy\");\n$RefreshReg$(_c2, \"ProductCard\");\n$RefreshReg$(_c3, \"Pagination$lazy\");\n$RefreshReg$(_c4, \"Pagination\");\n$RefreshReg$(_c5, \"Index\");\n\nwindow.$RefreshReg$ = prevRefreshReg;\nwindow.$RefreshSig$ = prevRefreshSig;", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n", "// REMIX HMR BEGIN\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\nimport.meta.hot = __hmr__.createHotContext(\n//@ts-expect-error\n\"app/utils/indexedDb.ts\"\n);\nimport.meta.hot.lastModified = \"1749033510030.6238\";\n}\n// REMIX HMR END\n\n// db.ts\nimport { openDB } from 'idb';\n\nconst STORE_NAME = 'products';\n\nexport const initDB = async () => {\n  return await openDB('EcommerceDB', 1, {\n    upgrade(db) {\n      if (!db.objectStoreNames.contains(STORE_NAME)) {\n        db.createObjectStore(STORE_NAME);\n      }\n    },\n  });\n};\n\nexport const saveToIndexedDB = async (data: any) => {\n  const db = await initDB();\n  await db.put(STORE_NAME, data, 'data');\n};\n\nexport const getFromIndexedDB = async () => {\n  const db = await initDB();\n  return await db.get(STORE_NAME, 'data');\n};\n"],
  "mappings": "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",
  "names": ["import_react", "target"]
}
